this.initilaze = function(numPlayer) {
	        this.player1 = new Player(game_configs["p1Start"], "red");
        if(numPlayer === 2) {
            this.player2 = new Player(game_configs["p2Start"], "blue");
        }

}

then i think the "this" in the function might end up acting like a constructor!!

so Map takes in number of players then.


----> reference/alias.
    this.placeBomb = function(i,j,map,canvas) {
        var tile = map.blocks[i][j];
        var next_index = tile.above.length;
        console.log(tile.above);
        tile.above[next_index] = new Item({type: "bomb", imgsrc: this.images["bomb"]});
        //update map
        map.blocks[i][j] = tile;
        console.log(tile.above);
    //    var setOffBomb = window.setTimeout(function() {this.explodeBomb(i,j,canvas)},2000);
    }

    it takes map. but if map is updated, then the new updated map is used o_O


    1. push bomb on top of grass - but what if there is an object and you're placing a bomb? destroyed or not?



    //controller. add bomb to above.
    this.placeBomb = function(i,j,map) {
        var bomb = new Item({type: "bomb", imgsrc: this.images["bomb"]});
        //push bomb on top of grass
        map.blocks[i][j].above.push(bomb);
        var setOffBomb = window.setTimeout(function() {this.explodeBomb(i,j,map)},2000);
    };
    //controller add fire 
    this.explodeBomb = function(i,j,map) {

        board = map.blocks;
        
        //Local function 
        function fireaway(dir) {
            // (i,j) is the position of bomb
            // (pos.i,pos.j) is the position of fire
            var head = dir[2];
            if (head === "X")
                fireImg = this.images["fire-X"];
            else
                fireImg = this.images["fire-Y"];
            var pos = {i: i+dir[0], j: j+dir[1]};
            var currTile = board[pos.i][pos.j];
            while (currTile.type != "wall"){
                var fire = new Item({type: "fire",imgsrc: fireImg});
                //if objects on top of grass, destroy block (remove from the list)
                if (currTile.above.length > 0)
                    board[pos.i][pos.j].above.pop; 
                //push fire into the list
                board[pos.i][pos.j].above.push(fire);
                pos.i += dir[0];
                pos.j += dir[1];
                }
                //update map.blocks
                map.blocks = board; 
            }

        var directions = {left: (-1,0,"X"), right:(+1,0,"X"), down: (0,+1,"Y"), up: (0,-1,"Y")};
        var paths = Object.keys(directions);
        paths.forEach(function(path) {
            fireaway(directions[path])
        });
    };
-----> window object has no "explode bombd"



//Player 1 = red by default
//Player 2 = blue by default
// pos, color, images, lives
// dictionary of objects.
function Player(player) {
    if (player === "p1" || (player === undefined)) {
        //by default atleast a single player (start position)
        this.pos = game_configs["p1Start"];
        this.color = game_configs["p1Color"];
        this.images = p1_images;
    }
    else {
        this.pos = game_configs["p2Start"];
        this.color = game_configs["p2Color"];
        this.images = p2_images;
    }
        
    this.lives = 3;
    this.objects = {
        bombCount: 0,
        keyCount: 0,
        hasExitKey: false,
        blocks: 0,
    };

    var that = this;
    //controller. add bomb to above.
    this.placeBomb = function(i,j,map) {
        var bomb = new Item({type: "bomb", imgsrc: this.images["bomb"]});
        //push bomb on top of grass
        map.blocks[i][j].above.push(bomb);
        var setOffBomb = window.setTimeout(function() {that.explodeBomb(i,j,map)},2000);
    };
    //controller add fire 
    this.explodeBomb = function(i,j,map) {

        board = map.blocks;
        
        //Local function 
        function fireaway(dir) {
            // (i,j) is the position of bomb
            // (pos.i,pos.j) is the position of fire
            var axis = dir[2];
            var fireImg;
            if (axis === "X")
                fireImg = that.images["fire-X"];
            else
                fireImg = that.images["fire-Y"];
            var pos = {i: i+dir[0], j: j+dir[1]};
            var currTile = board[pos.i][pos.j];
            while (currTile.type != "wall"){
                var fire = new Item({type: "fire",imgsrc: fireImg});
                //if objects on top of grass, destroy block (remove from the list)
                if (currTile.above.length > 0)
                    board[pos.i][pos.j].above.pop; 
                //push fire into the list
                board[pos.i][pos.j].above.push(fire);
                pos.i += dir[0];
                pos.j += dir[1];
                }
                //update map.blocks
                map.blocks = board; 
            }

        var directions = {left: (-1,0,"X"), right:(+1,0,"X"), down: (0,+1,"Y"), up: (0,-1,"Y")};
        var paths = Object.keys(directions);
        paths.forEach(function(path) {
            fireaway(directions[path])
        });
    };





    //draw the Player
    this.draw = function (context, viewport) {
       // console.log(this.pos);
        context.save();
        context.fillStyle = this.color;
        context.fillRect(inPixels(this.pos.i-viewport.viewLeft),inPixels(this.pos.j-viewport.viewTop),10,10);
        context.restore();
    };
};

-----> 50 (cannot read NaN property of undefinec)

.... ----> DOES THE WAY YOU WRITE A DICTIONARY MATTER?

---->
    this.explodeBomb = function(i,j,map) {
        var board = map.blocks;
        var directions = {"left": [-1,0,"X"], "right":[+1,0,"X"], 
                          "down": [0,+1,"Y"], "up": [0,-1,"Y"]};
        var paths = Object.keys(directions);
        paths.forEach(function(path) {
            console.log(directions[path]);
            this.fireaway(directions[path],i,j,map);
        });
    };

window has no fireaway



1______------->>>>>. Fix number of times fire is added to bomb area.